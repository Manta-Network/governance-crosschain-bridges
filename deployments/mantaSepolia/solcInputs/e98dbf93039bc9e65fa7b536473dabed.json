{
  "language": "Solidity",
  "sources": {
    "contracts/bridges/ArbitrumBridgeExecutor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {AddressAliasHelper} from '../dependencies/arbitrum/AddressAliasHelper.sol';\nimport {L2BridgeExecutor} from './L2BridgeExecutor.sol';\n\n/**\n * @title ArbitrumBridgeExecutor\n * @author Aave\n * @notice Implementation of the Arbitrum Bridge Executor, able to receive cross-chain transactions from Ethereum\n * @dev Queuing an ActionsSet into this Executor can only be done by the L2 Address Alias of the L1 EthereumGovernanceExecutor\n */\ncontract ArbitrumBridgeExecutor is L2BridgeExecutor {\n  /// @inheritdoc L2BridgeExecutor\n  modifier onlyEthereumGovernanceExecutor() override {\n    if (AddressAliasHelper.undoL1ToL2Alias(msg.sender) != _ethereumGovernanceExecutor)\n      revert UnauthorizedEthereumExecutor();\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   *\n   * @param ethereumGovernanceExecutor The address of the EthereumGovernanceExecutor\n   * @param delay The delay before which an actions set can be executed\n   * @param gracePeriod The time period after a delay during which an actions set can be executed\n   * @param minimumDelay The minimum bound a delay can be set to\n   * @param maximumDelay The maximum bound a delay can be set to\n   * @param guardian The address of the guardian, which can cancel queued proposals (can be zero)\n   */\n  constructor(\n    address ethereumGovernanceExecutor,\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  )\n    L2BridgeExecutor(\n      ethereumGovernanceExecutor,\n      delay,\n      gracePeriod,\n      minimumDelay,\n      maximumDelay,\n      guardian\n    )\n  {\n    // Intentionally left blank\n  }\n}\n"
    },
    "contracts/bridges/BridgeExecutorBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {IExecutorBase} from '../interfaces/IExecutorBase.sol';\n\n/**\n * @title BridgeExecutorBase\n * @author Aave\n * @notice Abstract contract that implements basic executor functionality\n * @dev It does not implement an external `queue` function. This should instead be done in the inheriting\n * contract with proper access control\n */\nabstract contract BridgeExecutorBase is IExecutorBase {\n  // Minimum allowed grace period, which reduces the risk of having an actions set expire due to network congestion\n  uint256 constant MINIMUM_GRACE_PERIOD = 10 minutes;\n\n  // Time between queuing and execution\n  uint256 private _delay;\n  // Time after the execution time during which the actions set can be executed\n  uint256 private _gracePeriod;\n  // Minimum allowed delay\n  uint256 private _minimumDelay;\n  // Maximum allowed delay\n  uint256 private _maximumDelay;\n  // Address with the ability of canceling actions sets\n  address private _guardian;\n\n  // Number of actions sets\n  uint256 private _actionsSetCounter;\n  // Map of registered actions sets (id => ActionsSet)\n  mapping(uint256 => ActionsSet) private _actionsSets;\n  // Map of queued actions (actionHash => isQueued)\n  mapping(bytes32 => bool) private _queuedActions;\n\n  /**\n   * @dev Only guardian can call functions marked by this modifier.\n   **/\n  modifier onlyGuardian() {\n    if (msg.sender != _guardian) revert NotGuardian();\n    _;\n  }\n\n  /**\n   * @dev Only this contract can call functions marked by this modifier.\n   **/\n  modifier onlyThis() {\n    if (msg.sender != address(this)) revert OnlyCallableByThis();\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   *\n   * @param delay The delay before which an actions set can be executed\n   * @param gracePeriod The time period after a delay during which an actions set can be executed\n   * @param minimumDelay The minimum bound a delay can be set to\n   * @param maximumDelay The maximum bound a delay can be set to\n   * @param guardian The address of the guardian, which can cancel queued proposals (can be zero)\n   */\n  constructor(\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) {\n    if (\n      gracePeriod < MINIMUM_GRACE_PERIOD ||\n      minimumDelay >= maximumDelay ||\n      delay < minimumDelay ||\n      delay > maximumDelay\n    ) revert InvalidInitParams();\n\n    _updateDelay(delay);\n    _updateGracePeriod(gracePeriod);\n    _updateMinimumDelay(minimumDelay);\n    _updateMaximumDelay(maximumDelay);\n    _updateGuardian(guardian);\n  }\n\n  /// @inheritdoc IExecutorBase\n  function execute(uint256 actionsSetId) external payable override {\n    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    if (block.timestamp < actionsSet.executionTime) revert TimelockNotFinished();\n\n    actionsSet.executed = true;\n    uint256 actionCount = actionsSet.targets.length;\n\n    bytes[] memory returnedData = new bytes[](actionCount);\n    for (uint256 i = 0; i < actionCount; ) {\n      returnedData[i] = _executeTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit ActionsSetExecuted(actionsSetId, msg.sender, returnedData);\n  }\n\n  /// @inheritdoc IExecutorBase\n  function cancel(uint256 actionsSetId) external override onlyGuardian {\n    if (getCurrentState(actionsSetId) != ActionsSetState.Queued) revert OnlyQueuedActions();\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.canceled = true;\n\n    uint256 targetsLength = actionsSet.targets.length;\n    for (uint256 i = 0; i < targetsLength; ) {\n      _cancelTransaction(\n        actionsSet.targets[i],\n        actionsSet.values[i],\n        actionsSet.signatures[i],\n        actionsSet.calldatas[i],\n        actionsSet.executionTime,\n        actionsSet.withDelegatecalls[i]\n      );\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit ActionsSetCanceled(actionsSetId);\n  }\n\n  /// @inheritdoc IExecutorBase\n  function updateGuardian(address guardian) external override onlyThis {\n    _updateGuardian(guardian);\n  }\n\n  /// @inheritdoc IExecutorBase\n  function updateDelay(uint256 delay) external override onlyThis {\n    _validateDelay(delay);\n    _updateDelay(delay);\n  }\n\n  /// @inheritdoc IExecutorBase\n  function updateGracePeriod(uint256 gracePeriod) external override onlyThis {\n    if (gracePeriod < MINIMUM_GRACE_PERIOD) revert GracePeriodTooShort();\n    _updateGracePeriod(gracePeriod);\n  }\n\n  /// @inheritdoc IExecutorBase\n  function updateMinimumDelay(uint256 minimumDelay) external override onlyThis {\n    if (minimumDelay >= _maximumDelay) revert MinimumDelayTooLong();\n    _updateMinimumDelay(minimumDelay);\n    _validateDelay(_delay);\n  }\n\n  /// @inheritdoc IExecutorBase\n  function updateMaximumDelay(uint256 maximumDelay) external override onlyThis {\n    if (maximumDelay <= _minimumDelay) revert MaximumDelayTooShort();\n    _updateMaximumDelay(maximumDelay);\n    _validateDelay(_delay);\n  }\n\n  /// @inheritdoc IExecutorBase\n  function executeDelegateCall(address target, bytes calldata data)\n    external\n    payable\n    override\n    onlyThis\n    returns (bool, bytes memory)\n  {\n    bool success;\n    bytes memory resultData;\n    // solium-disable-next-line security/no-call-value\n    (success, resultData) = target.delegatecall(data);\n    return (success, resultData);\n  }\n\n  /// @inheritdoc IExecutorBase\n  function receiveFunds() external payable override {}\n\n  /// @inheritdoc IExecutorBase\n  function getDelay() external view override returns (uint256) {\n    return _delay;\n  }\n\n  /// @inheritdoc IExecutorBase\n  function getGracePeriod() external view override returns (uint256) {\n    return _gracePeriod;\n  }\n\n  /// @inheritdoc IExecutorBase\n  function getMinimumDelay() external view override returns (uint256) {\n    return _minimumDelay;\n  }\n\n  /// @inheritdoc IExecutorBase\n  function getMaximumDelay() external view override returns (uint256) {\n    return _maximumDelay;\n  }\n\n  /// @inheritdoc IExecutorBase\n  function getGuardian() external view override returns (address) {\n    return _guardian;\n  }\n\n  /// @inheritdoc IExecutorBase\n  function getActionsSetCount() external view override returns (uint256) {\n    return _actionsSetCounter;\n  }\n\n  /// @inheritdoc IExecutorBase\n  function getActionsSetById(uint256 actionsSetId)\n    external\n    view\n    override\n    returns (ActionsSet memory)\n  {\n    return _actionsSets[actionsSetId];\n  }\n\n  /// @inheritdoc IExecutorBase\n  function getCurrentState(uint256 actionsSetId) public view override returns (ActionsSetState) {\n    if (_actionsSetCounter <= actionsSetId) revert InvalidActionsSetId();\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    if (actionsSet.canceled) {\n      return ActionsSetState.Canceled;\n    } else if (actionsSet.executed) {\n      return ActionsSetState.Executed;\n    } else if (block.timestamp > actionsSet.executionTime + _gracePeriod) {\n      return ActionsSetState.Expired;\n    } else {\n      return ActionsSetState.Queued;\n    }\n  }\n\n  /// @inheritdoc IExecutorBase\n  function isActionQueued(bytes32 actionHash) public view override returns (bool) {\n    return _queuedActions[actionHash];\n  }\n\n  function _updateGuardian(address guardian) internal {\n    emit GuardianUpdate(_guardian, guardian);\n    _guardian = guardian;\n  }\n\n  function _updateDelay(uint256 delay) internal {\n    emit DelayUpdate(_delay, delay);\n    _delay = delay;\n  }\n\n  function _updateGracePeriod(uint256 gracePeriod) internal {\n    emit GracePeriodUpdate(_gracePeriod, gracePeriod);\n    _gracePeriod = gracePeriod;\n  }\n\n  function _updateMinimumDelay(uint256 minimumDelay) internal {\n    emit MinimumDelayUpdate(_minimumDelay, minimumDelay);\n    _minimumDelay = minimumDelay;\n  }\n\n  function _updateMaximumDelay(uint256 maximumDelay) internal {\n    emit MaximumDelayUpdate(_maximumDelay, maximumDelay);\n    _maximumDelay = maximumDelay;\n  }\n\n  /**\n   * @notice Queue an ActionsSet\n   * @dev If a signature is empty, calldata is used for the execution, calldata is appended to signature otherwise\n   * @param targets Array of targets to be called by the actions set\n   * @param values Array of values to pass in each call by the actions set\n   * @param signatures Array of function signatures to encode in each call (can be empty)\n   * @param calldatas Array of calldata to pass in each call (can be empty)\n   * @param withDelegatecalls Array of whether to delegatecall for each call\n   **/\n  function _queue(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls\n  ) internal {\n    if (targets.length == 0) revert EmptyTargets();\n    uint256 targetsLength = targets.length;\n    if (\n      targetsLength != values.length ||\n      targetsLength != signatures.length ||\n      targetsLength != calldatas.length ||\n      targetsLength != withDelegatecalls.length\n    ) revert InconsistentParamsLength();\n\n    uint256 actionsSetId = _actionsSetCounter;\n    uint256 executionTime = block.timestamp + _delay;\n    unchecked {\n      ++_actionsSetCounter;\n    }\n\n    for (uint256 i = 0; i < targetsLength; ) {\n      bytes32 actionHash = keccak256(\n        abi.encode(\n          targets[i],\n          values[i],\n          signatures[i],\n          calldatas[i],\n          executionTime,\n          withDelegatecalls[i]\n        )\n      );\n      if (isActionQueued(actionHash)) revert DuplicateAction();\n      _queuedActions[actionHash] = true;\n      unchecked {\n        ++i;\n      }\n    }\n\n    ActionsSet storage actionsSet = _actionsSets[actionsSetId];\n    actionsSet.targets = targets;\n    actionsSet.values = values;\n    actionsSet.signatures = signatures;\n    actionsSet.calldatas = calldatas;\n    actionsSet.withDelegatecalls = withDelegatecalls;\n    actionsSet.executionTime = executionTime;\n\n    emit ActionsSetQueued(\n      actionsSetId,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      withDelegatecalls,\n      executionTime\n    );\n  }\n\n  function _executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal returns (bytes memory) {\n    if (address(this).balance < value) revert InsufficientBalance();\n\n    bytes32 actionHash = keccak256(\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n    );\n    _queuedActions[actionHash] = false;\n\n    bytes memory callData;\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    bool success;\n    bytes memory resultData;\n    if (withDelegatecall) {\n      (success, resultData) = this.executeDelegateCall{value: value}(target, callData);\n    } else {\n      // solium-disable-next-line security/no-call-value\n      (success, resultData) = target.call{value: value}(callData);\n    }\n    return _verifyCallResult(success, resultData);\n  }\n\n  function _cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 executionTime,\n    bool withDelegatecall\n  ) internal {\n    bytes32 actionHash = keccak256(\n      abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n    );\n    _queuedActions[actionHash] = false;\n  }\n\n  function _validateDelay(uint256 delay) internal view {\n    if (delay < _minimumDelay) revert DelayShorterThanMin();\n    if (delay > _maximumDelay) revert DelayLongerThanMax();\n  }\n\n  function _verifyCallResult(bool success, bytes memory returnData)\n    private\n    pure\n    returns (bytes memory)\n  {\n    if (success) {\n      return returnData;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returnData.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n          let returndata_size := mload(returnData)\n          revert(add(32, returnData), returndata_size)\n        }\n      } else {\n        revert FailedActionExecution();\n      }\n    }\n  }\n}\n"
    },
    "contracts/bridges/L2BridgeExecutor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {IL2BridgeExecutor} from '../interfaces/IL2BridgeExecutor.sol';\nimport {BridgeExecutorBase} from './BridgeExecutorBase.sol';\n\n/**\n * @title L2BridgeExecutor\n * @author Aave\n * @notice Abstract contract that implements bridge executor functionality for L2\n * @dev It does not implement the `onlyEthereumGovernanceExecutor` modifier. This should instead be done in the inheriting\n * contract with proper configuration and adjustments depending on the L2\n */\nabstract contract L2BridgeExecutor is BridgeExecutorBase, IL2BridgeExecutor {\n  // Address of the Ethereum Governance Executor, which should be able to queue actions sets\n  address internal _ethereumGovernanceExecutor;\n\n  /**\n   * @dev Only the Ethereum Governance Executor should be able to call functions marked by this modifier.\n   **/\n  modifier onlyEthereumGovernanceExecutor() virtual;\n\n  /**\n   * @dev Constructor\n   *\n   * @param ethereumGovernanceExecutor The address of the EthereumGovernanceExecutor\n   * @param delay The delay before which an actions set can be executed\n   * @param gracePeriod The time period after a delay during which an actions set can be executed\n   * @param minimumDelay The minimum bound a delay can be set to\n   * @param maximumDelay The maximum bound a delay can be set to\n   * @param guardian The address of the guardian, which can cancel queued proposals (can be zero)\n   */\n  constructor(\n    address ethereumGovernanceExecutor,\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) BridgeExecutorBase(delay, gracePeriod, minimumDelay, maximumDelay, guardian) {\n    _ethereumGovernanceExecutor = ethereumGovernanceExecutor;\n  }\n\n  /// @inheritdoc IL2BridgeExecutor\n  function queue(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls\n  ) external onlyEthereumGovernanceExecutor {\n    _queue(targets, values, signatures, calldatas, withDelegatecalls);\n  }\n\n  /// @inheritdoc IL2BridgeExecutor\n  function updateEthereumGovernanceExecutor(address ethereumGovernanceExecutor) external onlyThis {\n    emit EthereumGovernanceExecutorUpdate(_ethereumGovernanceExecutor, ethereumGovernanceExecutor);\n    _ethereumGovernanceExecutor = ethereumGovernanceExecutor;\n  }\n\n  /// @inheritdoc IL2BridgeExecutor\n  function getEthereumGovernanceExecutor() external view returns (address) {\n    return _ethereumGovernanceExecutor;\n  }\n}\n"
    },
    "contracts/bridges/OptimismBridgeExecutor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {ICrossDomainMessenger} from '../dependencies/optimism/interfaces/ICrossDomainMessenger.sol';\nimport {L2BridgeExecutor} from './L2BridgeExecutor.sol';\n\n/**\n * @title OptimismBridgeExecutor\n * @author Aave\n * @notice Implementation of the Optimism Bridge Executor, able to receive cross-chain transactions from Ethereum\n * @dev Queuing an ActionsSet into this Executor can only be done by the Optimism L2 Cross Domain Messenger and having\n * the EthereumGovernanceExecutor as xDomainMessageSender\n */\ncontract OptimismBridgeExecutor is L2BridgeExecutor {\n  // Address of the Optimism L2 Cross Domain Messenger, in charge of redirecting cross-chain transactions in L2\n  address public immutable OVM_L2_CROSS_DOMAIN_MESSENGER;\n\n  /// @inheritdoc L2BridgeExecutor\n  modifier onlyEthereumGovernanceExecutor() override {\n    if (\n      msg.sender != OVM_L2_CROSS_DOMAIN_MESSENGER ||\n      ICrossDomainMessenger(OVM_L2_CROSS_DOMAIN_MESSENGER).xDomainMessageSender() !=\n      _ethereumGovernanceExecutor\n    ) revert UnauthorizedEthereumExecutor();\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   *\n   * @param ovmL2CrossDomainMessenger The address of the Optimism L2CrossDomainMessenger\n   * @param ethereumGovernanceExecutor The address of the EthereumGovernanceExecutor\n   * @param delay The delay before which an actions set can be executed\n   * @param gracePeriod The time period after a delay during which an actions set can be executed\n   * @param minimumDelay The minimum bound a delay can be set to\n   * @param maximumDelay The maximum bound a delay can be set to\n   * @param guardian The address of the guardian, which can cancel queued proposals (can be zero)\n   */\n  constructor(\n    address ovmL2CrossDomainMessenger,\n    address ethereumGovernanceExecutor,\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  )\n    L2BridgeExecutor(\n      ethereumGovernanceExecutor,\n      delay,\n      gracePeriod,\n      minimumDelay,\n      maximumDelay,\n      guardian\n    )\n  {\n    OVM_L2_CROSS_DOMAIN_MESSENGER = ovmL2CrossDomainMessenger;\n  }\n}\n"
    },
    "contracts/bridges/PolygonBridgeExecutor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {IFxMessageProcessor} from '../dependencies/polygon/fxportal/interfaces/IFxMessageProcessor.sol';\nimport {BridgeExecutorBase} from './BridgeExecutorBase.sol';\n\n/**\n * @title PolygonBridgeExecutor\n * @author Aave\n * @notice Implementation of the Polygon Bridge Executor, able to receive cross-chain transactions from Ethereum\n * @dev Queuing an ActionsSet into this Executor can only be done by the FxChild and after passing the EthereumGovernanceExecutor check\n * as the FxRoot sender\n */\ncontract PolygonBridgeExecutor is BridgeExecutorBase, IFxMessageProcessor {\n  error UnauthorizedChildOrigin();\n  error UnauthorizedRootOrigin();\n\n  /**\n   * @dev Emitted when the FxRoot Sender is updated\n   * @param oldFxRootSender The address of the old FxRootSender\n   * @param newFxRootSender The address of the new FxRootSender\n   **/\n  event FxRootSenderUpdate(address oldFxRootSender, address newFxRootSender);\n\n  /**\n   * @dev Emitted when the FxChild is updated\n   * @param oldFxChild The address of the old FxChild\n   * @param newFxChild The address of the new FxChild\n   **/\n  event FxChildUpdate(address oldFxChild, address newFxChild);\n\n  // Address of the FxRoot Sender, sending the cross-chain transaction from Ethereum\n  address private _fxRootSender;\n  // Address of the FxChild, in charge of redirecting cross-chain transactions in Polygon\n  address private _fxChild;\n\n  /**\n   * @dev Only FxChild can call functions marked by this modifier.\n   **/\n  modifier onlyFxChild() {\n    if (msg.sender != _fxChild) revert UnauthorizedChildOrigin();\n    _;\n  }\n\n  /**\n   * @dev Constructor\n   *\n   * @param fxRootSender The address of the transaction sender in FxRoot\n   * @param fxChild The address of the FxChild\n   * @param delay The delay before which an actions set can be executed\n   * @param gracePeriod The time period after a delay during which an actions set can be executed\n   * @param minimumDelay The minimum bound a delay can be set to\n   * @param maximumDelay The maximum bound a delay can be set to\n   * @param guardian The address of the guardian, which can cancel queued proposals (can be zero)\n   */\n  constructor(\n    address fxRootSender,\n    address fxChild,\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) BridgeExecutorBase(delay, gracePeriod, minimumDelay, maximumDelay, guardian) {\n    _fxRootSender = fxRootSender;\n    _fxChild = fxChild;\n  }\n\n  /// @inheritdoc IFxMessageProcessor\n  function processMessageFromRoot(\n    uint256 stateId,\n    address rootMessageSender,\n    bytes calldata data\n  ) external override onlyFxChild {\n    if (rootMessageSender != _fxRootSender) revert UnauthorizedRootOrigin();\n\n    address[] memory targets;\n    uint256[] memory values;\n    string[] memory signatures;\n    bytes[] memory calldatas;\n    bool[] memory withDelegatecalls;\n\n    (targets, values, signatures, calldatas, withDelegatecalls) = abi.decode(\n      data,\n      (address[], uint256[], string[], bytes[], bool[])\n    );\n\n    _queue(targets, values, signatures, calldatas, withDelegatecalls);\n  }\n\n  /**\n   * @notice Update the address of the FxRoot Sender\n   * @param fxRootSender The address of the new FxRootSender\n   **/\n  function updateFxRootSender(address fxRootSender) external onlyThis {\n    emit FxRootSenderUpdate(_fxRootSender, fxRootSender);\n    _fxRootSender = fxRootSender;\n  }\n\n  /**\n   * @notice Update the address of the FxChild\n   * @param fxChild The address of the new FxChild\n   **/\n  function updateFxChild(address fxChild) external onlyThis {\n    emit FxChildUpdate(_fxChild, fxChild);\n    _fxChild = fxChild;\n  }\n\n  /**\n   * @notice Returns the address of the FxRoot Sender\n   * @return The address of the FxRootSender\n   **/\n  function getFxRootSender() external view returns (address) {\n    return _fxRootSender;\n  }\n\n  /**\n   * @notice Returns the address of the FxChild\n   * @return fxChild The address of FxChild\n   **/\n  function getFxChild() external view returns (address) {\n    return _fxChild;\n  }\n}\n"
    },
    "contracts/dependencies/arbitrum/AddressAliasHelper.sol": {
      "content": "// Copyright 2021-2022, Offchain Labs, Inc.\n// For license information, see https://github.com/nitro/blob/master/LICENSE\n// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n    uint160 internal constant OFFSET = uint160(0x1111000000000000000000000000000000001111);\n\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\n    /// the inbox to the msg.sender viewed in the L2\n    /// @param l1Address the address in the L1 that triggered the tx to L2\n    /// @return l2Address L2 address as viewed in msg.sender\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n        unchecked {\n            l2Address = address(uint160(l1Address) + OFFSET);\n        }\n    }\n\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n    /// address in the L1 that submitted a tx to the inbox\n    /// @param l2Address L2 address as viewed in msg.sender\n    /// @return l1Address the address in the L1 that triggered the tx to L2\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n        unchecked {\n            l1Address = address(uint160(l2Address) - OFFSET);\n        }\n    }\n}"
    },
    "contracts/dependencies/arbitrum/interfaces/ArbRetryableTx.sol": {
      "content": "pragma solidity >=0.4.21 <0.9.0;\n\n/**\n * @title precompiled contract in every Arbitrum chain for retryable transaction related data retrieval and interactions. Exists at 0x000000000000000000000000000000000000006E\n */\ninterface ArbRetryableTx {\n  /**\n   * @notice Redeem a redeemable tx.\n   * Revert if called by an L2 contract, or if userTxHash does not exist, or if userTxHash reverts.\n   * If this returns, userTxHash has been completed and is no longer available for redemption.\n   * If this reverts, userTxHash is still available for redemption (until it times out or is canceled).\n   * @param userTxHash unique identifier of retryable message: keccak256(keccak256(ArbchainId, inbox-sequence-number), uint(0) )\n   */\n  function redeem(bytes32 userTxHash) external;\n\n  /**\n   * @notice Return the minimum lifetime of redeemable txn.\n   * @return lifetime in seconds\n   */\n  function getLifetime() external view returns (uint256);\n\n  /**\n   * @notice Return the timestamp when userTxHash will age out, or zero if userTxHash does not exist.\n   * The timestamp could be in the past, because aged-out tickets might not be discarded immediately.\n   * @param userTxHash unique ticket identifier\n   * @return timestamp for ticket's deadline\n   */\n  function getTimeout(bytes32 userTxHash) external view returns (uint256);\n\n  /**\n   * @notice Return the price, in wei, of submitting a new retryable tx with a given calldata size.\n   * @param calldataSize call data size to get price of (in wei)\n   * @return (price, nextUpdateTimestamp). Price is guaranteed not to change until nextUpdateTimestamp.\n   */\n  function getSubmissionPrice(uint256 calldataSize) external view returns (uint256, uint256);\n\n  /**\n   * @notice Return the price, in wei, of extending the lifetime of userTxHash by an additional lifetime period. Revert if userTxHash doesn't exist.\n   * @param userTxHash unique ticket identifier\n   * @return (price, nextUpdateTimestamp). Price is guaranteed not to change until nextUpdateTimestamp.\n   */\n  function getKeepalivePrice(bytes32 userTxHash) external view returns (uint256, uint256);\n\n  /** \n    @notice Deposits callvalue into the sender's L2 account, then adds one lifetime period to the life of userTxHash.\n    * If successful, emits LifetimeExtended event.\n    * Revert if userTxHash does not exist, or if the timeout of userTxHash is already at least one lifetime period in the future, or if the sender has insufficient funds (after the deposit).\n    * @param userTxHash unique ticket identifier\n    * @return New timeout of userTxHash.\n    */\n  function keepalive(bytes32 userTxHash) external payable returns (uint256);\n\n  /**\n   * @notice Return the beneficiary of userTxHash.\n   * Revert if userTxHash doesn't exist.\n   * @param userTxHash unique ticket identifier\n   * @return address of beneficiary for ticket\n   */\n  function getBeneficiary(bytes32 userTxHash) external view returns (address);\n\n  /**\n   * @notice Cancel userTxHash and refund its callvalue to its beneficiary.\n   * Revert if userTxHash doesn't exist, or if called by anyone other than userTxHash's beneficiary.\n   * @param userTxHash unique ticket identifier\n   */\n  function cancel(bytes32 userTxHash) external;\n\n  event TicketCreated(bytes32 indexed userTxHash);\n  event LifetimeExtended(bytes32 indexed userTxHash, uint256 newTimeout);\n  event Redeemed(bytes32 indexed userTxHash);\n  event Canceled(bytes32 indexed userTxHash);\n}\n"
    },
    "contracts/dependencies/arbitrum/interfaces/IInbox.sol": {
      "content": "pragma solidity >=0.7.0;\n\ninterface IInbox {\n  function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n  function sendUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (uint256);\n\n  function sendContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (uint256);\n\n  function sendL1FundedUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function sendL1FundedContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function createRetryableTicket(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\n}\n"
    },
    "contracts/dependencies/optimism/interfaces/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n  /**********\n   * Events *\n   **********/\n\n  event SentMessage(\n    address indexed target,\n    address sender,\n    bytes message,\n    uint256 messageNonce,\n    uint256 gasLimit\n  );\n  event RelayedMessage(bytes32 indexed msgHash);\n  event FailedRelayedMessage(bytes32 indexed msgHash);\n\n  /*************\n   * Variables *\n   *************/\n\n  function xDomainMessageSender() external view returns (address);\n\n  /********************\n   * Public Functions *\n   ********************/\n\n  /**\n   * Sends a cross domain message to the target messenger.\n   * @param _target Target contract address.\n   * @param _message Message to send to the target.\n   * @param _gasLimit Gas limit for the provided message.\n   */\n  function sendMessage(\n    address _target,\n    bytes calldata _message,\n    uint32 _gasLimit\n  ) external;\n}\n"
    },
    "contracts/dependencies/polygon/fxportal/interfaces/IFxMessageProcessor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\n/**\n * @title IFxMessageProcessor\n * @notice Defines the interface to process message\n */\ninterface IFxMessageProcessor {\n  /**\n   * @notice Process the cross-chain message from a FxChild contract through the Ethereum/Polygon StateSender\n   * @param stateId The id of the cross-chain message created in the Ethereum/Polygon StateSender\n   * @param rootMessageSender The address that initially sent this message on Ethereum\n   * @param data The data from the abi-encoded cross-chain message\n   **/\n  function processMessageFromRoot(\n    uint256 stateId,\n    address rootMessageSender,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/interfaces/IExecutorBase.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @title IExecutorBase\n * @author Aave\n * @notice Defines the basic interface for the ExecutorBase abstract contract\n */\ninterface IExecutorBase {\n  error InvalidInitParams();\n  error NotGuardian();\n  error OnlyCallableByThis();\n  error MinimumDelayTooLong();\n  error MaximumDelayTooShort();\n  error GracePeriodTooShort();\n  error DelayShorterThanMin();\n  error DelayLongerThanMax();\n  error OnlyQueuedActions();\n  error TimelockNotFinished();\n  error InvalidActionsSetId();\n  error EmptyTargets();\n  error InconsistentParamsLength();\n  error DuplicateAction();\n  error InsufficientBalance();\n  error FailedActionExecution();\n\n  /**\n   * @notice This enum contains all possible actions set states\n   */\n  enum ActionsSetState {\n    Queued,\n    Executed,\n    Canceled,\n    Expired\n  }\n\n  /**\n   * @notice This struct contains the data needed to execute a specified set of actions\n   * @param targets Array of targets to call\n   * @param values Array of values to pass in each call\n   * @param signatures Array of function signatures to encode in each call (can be empty)\n   * @param calldatas Array of calldatas to pass in each call, appended to the signature at the same array index if not empty\n   * @param withDelegateCalls Array of whether to delegatecall for each call\n   * @param executionTime Timestamp starting from which the actions set can be executed\n   * @param executed True if the actions set has been executed, false otherwise\n   * @param canceled True if the actions set has been canceled, false otherwise\n   */\n  struct ActionsSet {\n    address[] targets;\n    uint256[] values;\n    string[] signatures;\n    bytes[] calldatas;\n    bool[] withDelegatecalls;\n    uint256 executionTime;\n    bool executed;\n    bool canceled;\n  }\n\n  /**\n   * @dev Emitted when an ActionsSet is queued\n   * @param id Id of the ActionsSet\n   * @param targets Array of targets to be called by the actions set\n   * @param values Array of values to pass in each call by the actions set\n   * @param signatures Array of function signatures to encode in each call by the actions set\n   * @param calldatas Array of calldata to pass in each call by the actions set\n   * @param withDelegatecalls Array of whether to delegatecall for each call of the actions set\n   * @param executionTime The timestamp at which this actions set can be executed\n   **/\n  event ActionsSetQueued(\n    uint256 indexed id,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    bool[] withDelegatecalls,\n    uint256 executionTime\n  );\n\n  /**\n   * @dev Emitted when an ActionsSet is successfully executed\n   * @param id Id of the ActionsSet\n   * @param initiatorExecution The address that triggered the ActionsSet execution\n   * @param returnedData The returned data from the ActionsSet execution\n   **/\n  event ActionsSetExecuted(\n    uint256 indexed id,\n    address indexed initiatorExecution,\n    bytes[] returnedData\n  );\n\n  /**\n   * @dev Emitted when an ActionsSet is cancelled by the guardian\n   * @param id Id of the ActionsSet\n   **/\n  event ActionsSetCanceled(uint256 indexed id);\n\n  /**\n   * @dev Emitted when a new guardian is set\n   * @param oldGuardian The address of the old guardian\n   * @param newGuardian The address of the new guardian\n   **/\n  event GuardianUpdate(address oldGuardian, address newGuardian);\n\n  /**\n   * @dev Emitted when the delay (between queueing and execution) is updated\n   * @param oldDelay The value of the old delay\n   * @param newDelay The value of the new delay\n   **/\n  event DelayUpdate(uint256 oldDelay, uint256 newDelay);\n\n  /**\n   * @dev Emitted when the grace period (between executionTime and expiration) is updated\n   * @param oldGracePeriod The value of the old grace period\n   * @param newGracePeriod The value of the new grace period\n   **/\n  event GracePeriodUpdate(uint256 oldGracePeriod, uint256 newGracePeriod);\n\n  /**\n   * @dev Emitted when the minimum delay (lower bound of delay) is updated\n   * @param oldMinimumDelay The value of the old minimum delay\n   * @param newMinimumDelay The value of the new minimum delay\n   **/\n  event MinimumDelayUpdate(uint256 oldMinimumDelay, uint256 newMinimumDelay);\n\n  /**\n   * @dev Emitted when the maximum delay (upper bound of delay)is updated\n   * @param oldMaximumDelay The value of the old maximum delay\n   * @param newMaximumDelay The value of the new maximum delay\n   **/\n  event MaximumDelayUpdate(uint256 oldMaximumDelay, uint256 newMaximumDelay);\n\n  /**\n   * @notice Execute the ActionsSet\n   * @param actionsSetId The id of the ActionsSet to execute\n   **/\n  function execute(uint256 actionsSetId) external payable;\n\n  /**\n   * @notice Cancel the ActionsSet\n   * @param actionsSetId The id of the ActionsSet to cancel\n   **/\n  function cancel(uint256 actionsSetId) external;\n\n  /**\n   * @notice Update guardian\n   * @param guardian The address of the new guardian\n   **/\n  function updateGuardian(address guardian) external;\n\n  /**\n   * @notice Update the delay, time between queueing and execution of ActionsSet\n   * @dev It does not affect to actions set that are already queued\n   * @param delay The value of the delay (in seconds)\n   **/\n  function updateDelay(uint256 delay) external;\n\n  /**\n   * @notice Update the grace period, the period after the execution time during which an actions set can be executed\n   * @param gracePeriod The value of the grace period (in seconds)\n   **/\n  function updateGracePeriod(uint256 gracePeriod) external;\n\n  /**\n   * @notice Update the minimum allowed delay\n   * @param minimumDelay The value of the minimum delay (in seconds)\n   **/\n  function updateMinimumDelay(uint256 minimumDelay) external;\n\n  /**\n   * @notice Update the maximum allowed delay\n   * @param maximumDelay The maximum delay (in seconds)\n   **/\n  function updateMaximumDelay(uint256 maximumDelay) external;\n\n  /**\n   * @notice Allows to delegatecall a given target with an specific amount of value\n   * @dev This function is external so it allows to specify a defined msg.value for the delegate call, reducing\n   * the risk that a delegatecall gets executed with more value than intended\n   * @return True if the delegate call was successful, false otherwise\n   * @return The bytes returned by the delegate call\n   **/\n  function executeDelegateCall(address target, bytes calldata data)\n    external\n    payable\n    returns (bool, bytes memory);\n\n  /**\n   * @notice Allows to receive funds into the executor\n   * @dev Useful for actionsSet that needs funds to gets executed\n   */\n  function receiveFunds() external payable;\n\n  /**\n   * @notice Returns the delay (between queuing and execution)\n   * @return The value of the delay (in seconds)\n   **/\n  function getDelay() external view returns (uint256);\n\n  /**\n   * @notice Returns the grace period\n   * @return The value of the grace period (in seconds)\n   **/\n  function getGracePeriod() external view returns (uint256);\n\n  /**\n   * @notice Returns the minimum delay\n   * @return The value of the minimum delay (in seconds)\n   **/\n  function getMinimumDelay() external view returns (uint256);\n\n  /**\n   * @notice Returns the maximum delay\n   * @return The value of the maximum delay (in seconds)\n   **/\n  function getMaximumDelay() external view returns (uint256);\n\n  /**\n   * @notice Returns the address of the guardian\n   * @return The address of the guardian\n   **/\n  function getGuardian() external view returns (address);\n\n  /**\n   * @notice Returns the total number of actions sets of the executor\n   * @return The number of actions sets\n   **/\n  function getActionsSetCount() external view returns (uint256);\n\n  /**\n   * @notice Returns the data of an actions set\n   * @param actionsSetId The id of the ActionsSet\n   * @return The data of the ActionsSet\n   **/\n  function getActionsSetById(uint256 actionsSetId) external view returns (ActionsSet memory);\n\n  /**\n   * @notice Returns the current state of an actions set\n   * @param actionsSetId The id of the ActionsSet\n   * @return The current state of theI ActionsSet\n   **/\n  function getCurrentState(uint256 actionsSetId) external view returns (ActionsSetState);\n\n  /**\n   * @notice Returns whether an actions set (by actionHash) is queued\n   * @dev actionHash = keccak256(abi.encode(target, value, signature, data, executionTime, withDelegatecall))\n   * @param actionHash hash of the action to be checked\n   * @return True if the underlying action of actionHash is queued, false otherwise\n   **/\n  function isActionQueued(bytes32 actionHash) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IL2BridgeExecutor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @title IL2BridgeExecutorBase\n * @author Aave\n * @notice Defines the basic interface for the L2BridgeExecutor abstract contract\n */\ninterface IL2BridgeExecutor {\n  error UnauthorizedEthereumExecutor();\n\n  /**\n   * @dev Emitted when the Ethereum Governance Executor is updated\n   * @param oldEthereumGovernanceExecutor The address of the old EthereumGovernanceExecutor\n   * @param newEthereumGovernanceExecutor The address of the new EthereumGovernanceExecutor\n   **/\n  event EthereumGovernanceExecutorUpdate(\n    address oldEthereumGovernanceExecutor,\n    address newEthereumGovernanceExecutor\n  );\n\n  /**\n   * @notice Queue an ActionsSet\n   * @dev If a signature is empty, calldata is used for the execution, calldata is appended to signature otherwise\n   * @param targets Array of targets to be called by the actions set\n   * @param values Array of values to pass in each call by the actions set\n   * @param signatures Array of function signatures to encode in each call by the actions (can be empty)\n   * @param calldatas Array of calldata to pass in each call by the actions set\n   * @param withDelegatecalls Array of whether to delegatecall for each call of the actions set\n   **/\n  function queue(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls\n  ) external;\n\n  /**\n   * @notice Update the address of the Ethereum Governance Executor\n   * @param ethereumGovernanceExecutor The address of the new EthereumGovernanceExecutor\n   **/\n  function updateEthereumGovernanceExecutor(address ethereumGovernanceExecutor) external;\n\n  /**\n   * @notice Returns the address of the Ethereum Governance Executor\n   * @return The address of the EthereumGovernanceExecutor\n   **/\n  function getEthereumGovernanceExecutor() external view returns (address);\n}\n"
    },
    "contracts/mocks/ArbGreeter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport {AddressAliasHelper} from './../dependencies/arbitrum/AddressAliasHelper.sol';\n\ncontract ArbGreeter {\n  event Senders(address msgSender, address applyAlias, address undoAlias);\n\n  event MessageUpdated(string newMessage);\n  string public message;\n\n  constructor() {}\n\n  function setMessage(string calldata newMessage) public {\n    message = newMessage;\n    emit MessageUpdated(newMessage);\n  }\n\n  function sender() public {\n    emit Senders(\n      msg.sender,\n      AddressAliasHelper.applyL1ToL2Alias(msg.sender),\n      AddressAliasHelper.undoL1ToL2Alias(msg.sender)\n    );\n  }\n}\n"
    },
    "contracts/mocks/Greeter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\ncontract Greeter {\n  event MessageUpdated(string newMessage);\n  string public message;\n\n  constructor() {}\n\n  function setMessage(string memory newMessage) public {\n    message = newMessage;\n    emit MessageUpdated(newMessage);\n  }\n}\n"
    },
    "contracts/mocks/GreeterPayload.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport {Greeter} from './Greeter.sol';\n\ncontract GreeterPayload {\n  event PayloadExecuted(address sender);\n\n  function execute(address greeter, string memory newMessage) external {\n    Greeter(greeter).setMessage(newMessage);\n    emit PayloadExecuted(msg.sender);\n  }\n}\n"
    },
    "contracts/mocks/MockInbox.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.7.0;\n\nimport {IInbox} from '../dependencies/arbitrum/interfaces/IInbox.sol';\nimport {AddressAliasHelper} from '../dependencies/arbitrum/AddressAliasHelper.sol';\n\ncontract MockInbox is IInbox {\n  uint256 public messageNum;\n\n  function setMessageNum(uint256 msgNum) external {\n    messageNum = msgNum;\n  }\n\n  function sendL2Message(\n    bytes calldata // messageData\n  ) external view override returns (uint256) {\n    return messageNum;\n  }\n\n  function sendUnsignedTransaction(\n    uint256, // maxGas\n    uint256, // gasPriceBid\n    uint256, // nonce\n    address, // destAddr\n    uint256, // amount\n    bytes calldata // data\n  ) external view override returns (uint256) {\n    return messageNum;\n  }\n\n  function sendContractTransaction(\n    uint256, // maxGas\n    uint256, // gasPriceBid\n    address, // destAddr\n    uint256, // amount\n    bytes calldata // data\n  ) external view override returns (uint256) {\n    return messageNum;\n  }\n\n  function sendL1FundedUnsignedTransaction(\n    uint256, // maxGas\n    uint256, // gasPriceBid\n    uint256, // nonce\n    address, // destAddr\n    bytes calldata // data\n  ) external payable override returns (uint256) {\n    return messageNum;\n  }\n\n  function sendL1FundedContractTransaction(\n    uint256, // maxGas\n    uint256, // gasPriceBid\n    address, // destAddr\n    bytes calldata // data\n  ) external payable override returns (uint256) {\n    return messageNum;\n  }\n\n  function createRetryableTicket(\n    address destAddr,\n    uint256, // arbTxCallValue\n    uint256, // maxSubmissionCost\n    address, // submissionRefundAddress\n    address, // valueRefundAddress\n    uint256 maxGas,\n    uint256, // gasPriceBid\n    bytes calldata data\n  ) external payable override returns (uint256) {\n    bool success;\n    (success, ) = destAddr.call{gas: maxGas}(data);\n    return messageNum;\n  }\n\n  function depositEth(\n    uint256 // maxSubmissionCost\n  ) external payable override returns (uint256) {\n    return messageNum;\n  }\n}\n"
    },
    "contracts/mocks/MockOvmL1CrossDomainMessenger.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport {ICrossDomainMessenger} from '../dependencies/optimism/interfaces/ICrossDomainMessenger.sol';\nimport {MockOvmL2CrossDomainMessenger} from './MockOvmL2CrossDomainMessenger.sol';\n\ncontract MockOvmL1CrossDomainMessenger is ICrossDomainMessenger {\n  address private sender;\n  address private l2Messenger;\n\n  function setSender(address _sender) external {\n    sender = _sender;\n  }\n\n  function setL2Messenger(address _l2Messenger) external {\n    l2Messenger = _l2Messenger;\n  }\n\n  function xDomainMessageSender() external view override returns (address) {\n    return sender;\n  }\n\n  function sendMessage(\n    address _target,\n    bytes calldata _message,\n    uint32 _gasLimit\n  ) external override {\n    MockOvmL2CrossDomainMessenger(l2Messenger).redirect(msg.sender, _target, _message, _gasLimit);\n  }\n\n  function redirect(\n    address _target,\n    bytes calldata _message,\n    uint32 _gasLimit\n  ) external {\n    bool success;\n    (success, ) = _target.call{gas: _gasLimit}(_message);\n  }\n}\n"
    },
    "contracts/mocks/MockOvmL2CrossDomainMessenger.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport {ICrossDomainMessenger} from '../dependencies/optimism/interfaces/ICrossDomainMessenger.sol';\nimport {MockOvmL1CrossDomainMessenger} from './MockOvmL1CrossDomainMessenger.sol';\n\ncontract MockOvmL2CrossDomainMessenger is ICrossDomainMessenger {\n  address private sender;\n  address private l1Messenger;\n\n  function setSender(address _sender) external {\n    sender = _sender;\n  }\n\n  function setL1Messenger(address _l1Messenger) external {\n    l1Messenger = _l1Messenger;\n  }\n\n  function xDomainMessageSender() external view override returns (address) {\n    return sender;\n  }\n\n  function sendMessage(\n    address _target,\n    bytes calldata _message,\n    uint32 _gasLimit\n  ) external override {\n    MockOvmL1CrossDomainMessenger(l1Messenger).redirect(_target, _message, _gasLimit);\n  }\n\n  // This error must be defined here or else Hardhat will not recognize the selector\n  error UnauthorizedEthereumExecutor();\n\n  function redirect(\n    address _xDomainMessageSender,\n    address _target,\n    bytes calldata _message,\n    uint32 _gasLimit\n  ) external {\n    sender = _xDomainMessageSender;\n    (bool success, bytes memory data) = _target.call{gas: _gasLimit}(_message);\n    if (!success) {\n      assembly {\n        revert(add(data, 32), mload(data))\n      }\n    }\n  }\n}\n"
    },
    "contracts/mocks/PolygonMarketUpdate.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\ncontract PolygonMarketUpdate {\n  event UpdateExecuted(uint256 counter, uint256 testInt, address testAddress, uint256 fee);\n  event DelegateUpdateExecuted(bytes32 testBytes, address sender);\n  address constant UPDATED_ADDRESS = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;\n\n  uint256 private _counter;\n  uint256 private _testInt;\n\n  function execute(uint256 testInt) external payable returns (uint256) {\n    _counter = _counter + 1;\n    _testInt = testInt;\n    emit UpdateExecuted(_counter, _testInt, UPDATED_ADDRESS, msg.value);\n    return testInt;\n  }\n\n  function executeWithDelegate(bytes32 testBytes) external payable {\n    emit DelegateUpdateExecuted(testBytes, msg.sender);\n  }\n\n  function alwaysFails() public {\n    _counter = _counter + 1;\n    require(1 < 0, 'THIS_ALWAYS_FAILS');\n  }\n\n  function getCounter() public view returns (uint256) {\n    return _counter;\n  }\n\n  function getTestInt() public view returns (uint256) {\n    return _testInt;\n  }\n}\n"
    },
    "contracts/mocks/Selfdestructor.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\ncontract Selfdestructor {\n  function oops() external {\n    selfdestruct(payable(msg.sender));\n  }\n}\n"
    },
    "contracts/mocks/SimpleBridgeExecutor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {BridgeExecutorBase} from '../bridges/BridgeExecutorBase.sol';\n\ncontract SimpleBridgeExecutor is BridgeExecutorBase {\n  constructor(\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  ) BridgeExecutorBase(delay, gracePeriod, minimumDelay, maximumDelay, guardian) {}\n\n  function queue(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    bool[] memory withDelegatecalls\n  ) external {\n    _queue(targets, values, signatures, calldatas, withDelegatecalls);\n  }\n}\n"
    },
    "contracts/mocks/SimpleL2BridgeExecutor.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {L2BridgeExecutor} from '../bridges/L2BridgeExecutor.sol';\n\ncontract SimpleL2BridgeExecutor is L2BridgeExecutor {\n  modifier onlyEthereumGovernanceExecutor() override {\n    if (msg.sender != _ethereumGovernanceExecutor) revert UnauthorizedEthereumExecutor();\n    _;\n  }\n\n  constructor(\n    address ethereumGovernanceExecutor,\n    uint256 delay,\n    uint256 gracePeriod,\n    uint256 minimumDelay,\n    uint256 maximumDelay,\n    address guardian\n  )\n    L2BridgeExecutor(\n      ethereumGovernanceExecutor,\n      delay,\n      gracePeriod,\n      minimumDelay,\n      maximumDelay,\n      guardian\n    )\n  {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}